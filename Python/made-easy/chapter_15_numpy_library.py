"""Библиотека NumPy."""

import numpy as np

# http://jalammar.github.io/ - руководство для программистов

# 15.1. Введение в NumPy
# NumPy (Numerical Python) - это библиотека Python с открытым исходным кодом,
# которая используется практически во всех областях науки и техники. Это универ
# сальный стандарт для работы с числовыми данными в Python, который лежит в ос-
# нове научных экосистем Python и PyData.
# В отличие от универсального Python, в который встроено множество структур
# данных, в NumPy есть всего одна структура - многомерный массив и различные
# производные объекты, в том числе матрицы.
# В основе NumPy лежит тип данных ndarray, который представляет собой однород-
# ный многомерный массив, а также методы для эффективной работы с ним. NumPy
# добавляет в Python мощные структуры данных, позволяющие выполнять эффек-
# тивные вычисления над массивами и матрицами, и предоставляет огромную биб-
# лиотеку высокоуровневых математических функций, которые работают с этими
# структурами данных.

# 15.1.2. Импорт NumPy
# Каждый раз, когда вы хотите использовать сторонний пакет или библиотеку в сво-
# ем коде, вам сначала нужно импортировать их.
# Чтобы начать использовать библиотеку NumPy и все ее функции, необходимо им-
# портировать ее с помощью оператора import:
# import numpy as np
# 15.1.3. Разница между списком Python
# и массивом NumPy
# В NumPy есть огромное количество быстрых и эффективных способов создания
# массивов и обработки их числовых данных. Python позволяет хранить в одном спи
# ске данные разных типов, но в массиве NumPy все элементы должны быть одного
# типа. Математические операции, которые выполняются над массивами, были бы
# очень неэффективными, если бы элементы в массивах не бьmи однородными.
# Сравнение списков list и массивов ndarray показано в табл. 15.1.

# ![image.png](attachment:image.png)

# 15.1.4. Зачем нам NumPy?
# Массивы NumPy быстрее и компактнее, чем списки Python. Массив занимает
# меньше памяти и удобнее в использовании. NumPy использует намного меньше
# памяти для хранения данных и имеет механизм для явного задания типа данных,
# что позволяет еще больше оптимизировать код.
# NumPy работает быстрее, чем списки, потому что массивы NumPy занимают мень
# ше места в памяти по сравнению со списками и, следовательно, быстрее
# загружаются.

# ![image.png](attachment:image.png)

# Как видите, объект list имеет 4 атрибута: размер, количество ссылок, тип объекта и
# значение объекта. Все это занимает 28 байт памяти. Тот же объект в форме массива
# NumPy занимает всего 4 байта памяти.
# Есть еще одно преимущество массива NumPy в том, что он хранится в памяти не
# прерывно. Это означает, что данные хранятся без пробелов между ними. А вот спи-
# ски разрознены.

# ![image.png](attachment:image.png)

# 15.2. Массив NumPy
# Массив - это центральная структура данных библиотеки NumPy. Массив пред-
# ставляет собой таблицу значений, содержащую информацию о необработанных
# данных, о том, как найти элемент и как интерпретировать элемент. В массиве есть
# сетка элементов, которые можно индексировать разными способами. Все элементы
# имеют один тип, который сохраняется в атрибуте dtype.
# Обратите внимание, что класс nШ11ру . array - это не то же самое,
# что класс array. array стандартной библиотеки Python, который обрабатывает только
# одномерные массивы и гораздо менее функционален.
# Один из способов инициализировать массив NumPy - выполнить преобразование
# из списка Python. Например:

alfa = np.array([1, 2, 3, 4, 5, 6])
alfa

# Или можно использовать вложенные списки для создания двумерных или много
# мерных данных:

beta = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
beta

# Получить доступ к элементам массива можно с помощью квадратных скобок. Пом-
# ните, что индексация в NumPy начинается с О. Это означает, что если вы хотите
# обратиться к первому элементу массива, нужно указывать индекс О.

print(beta[0])

# 15.2.1. Размерность массива
# Иногда массивы называют ndarray, что является сокращением от англ. N-dimen
# sional array (п-мерный массив). Здесь имеется в виду, что это просто массив
# с любым количеством измерений. Иногда также встречаются термины ID-массив
# (одномерный массив) и 2D-массив (двумерный массив). Класс NumPy ndarray
# используется для представления как матриц, так и векторов.
# Вектор представляет собой одномерный массив (вектор-строка или вектор
# столбец - это одно и то же).
# Матрица - это двумерный массив.
# Для трехмерных массивов или массивов более высокой размерности обычно ис-
# пользуется термин тензор.
# 15.2.2. Другие атрибуты массива
# Массив обычно представляет собой контейнер фиксированного размера с элемен-
# тами одного типа и размера. Размерность массива и количество элементов в масси-
# ве определяются его формой. Форма массива - это кортеж неотрицательных
# целых чисел, которые определяют размеры по каждому измерению.
# В NumPy измерения называются осями. Это означает, что если у вас есть двумер-
# ный массив, который выглядит так:

# ![image.png](attachment:image.png)

# В вашем массиве 2 оси. Первая ось имеет длину 2, а вторая ось - длину 3 .
# Как и в других контейнерах Python, к содержимому массива можно обращаться и
# изменять его с помощью индексации или среза. В отличие от типичных объектов
# контейнеров, разные массивы могут совместно использовать одни и те же данные,
# поэтому изменения, внесенные в один массив, могут быть видны и в другом мас-
# сиве.
#
# 15.3. Создание массива
# Чтобы создать массив NumPy, вы можете использовать функцию np.array().
# Чтобы создать простой массив, достаточно просто передать ему список.

arr = np.array([1, 2, 3])
arr

# Вы можете представить свой массив так, как изображено на рис. 15.3.
# ![image.png](attachment:image.png)

# Есть несколько способов создания массивов.
# Вы можете создать массив из обычного списка или кортежа Python, используя
# функцию np.array(). Тип результирующего массива будет определяться типом эле-
# ментов в последовательностях.

alfa1 = np.array([2, 3, 4])
alfa1

beta1 = np.array([1.2, 3.5, 5.1])
beta1

alfa1.dtype

beta1.dtype

# Довольно распространенная ошибка заключается в вызове этой функции с
# несколькими аргументами вместо передачи одной последовательности в качестве
# аргумента.

# ![image.png](attachment:image.png)

# Функция np.array() преобразует последовательность последовательностей в
# двумерный массив, а последовательность двумерных массивов - в трехмерный
# массив и т. д.

beta2 = np.array([(1.5, 2, 3), (4, 5, 6)])
beta2

# 15.3.1. Массивы из нулей, единиц и случайных чисел
#
# Часто элементы массива изначально неизвестны, известен лишь его размер. Поэто-
# му в NumPy есть несколько функций для создания массивов с опеределенным на-
# чальным заполнителем. Это сводит к минимуму необходимость увеличения разме-
# ра массива в процессе работы, что требует немало ресурсов.
# Функция zeros() создает массив, заполненный нулями, функция ones() создает мас-
# сив, заполненный единицами. По умолчанию тип элементов таких массивов
# flоаt64.

np.zeros(2)

np.zeros((3, 4))

np.ones(2)

np.ones((3, 2))

# Функция empty() создает массив, начальное содержимое которого является
# случайным и зависит от состояния памяти. Причина использования массива
# случайных чисел вместо нулей - это скорость. Но после этого нужно заполнить
# каждый элемент!

# создание пустого массива с 2 элементами
np.empty((2, 3))

# Часто бывают случаи, когда мы хотим, чтобы NumPy сам задал значения массива.
# В NumPy есть также класс random . Generator для генерации случайных чисел. Вам
# достаточно лишь передать количество элементов, которые вы хотите сгенерировать
# (рис.15.4 и 15.5).

rng = np.random.default_rng(0)
rng.random(3)

rng.random((3, 2))

# ![image.png](attachment:image.png)

# 15.3.2. Массив из диапазона значений
#
# Для создания последовательностей чисел в NumPy есть функция np.arange(),
# работающая аналогично встроенной функции range() в Python, но возвращающая
# массив.

np.arange(4)

# Можно также создавать массивы, содержащие диапазон равномерно распределен
# ных значений. Для этого нужно указать первое число, последнее число и размер
# шага.

# +
# массив значений от 2 до 9 с шагом 2


np.arange(2, 9, 2)
# -

# Когда в arange() передают аргументы с плавающей точкой, обычно невозможно
# предсказать количество полученных элементов из-за конечной точности этого
# формата. Поэтому в таких случаях лучше использовать функцию linspace(),
# которая вместо шага принимает в качестве аргумента количество элементов.

np.linspace(0, 2, 9)  # 9 чисел от О до 2

# 15.3.3. Указание типа данных массива
# Хотя тип данных по умолчанию - это числа с плавающей точкой (np . float64 ),
# вы можете явно указать, какой тип данных вам нужен, используя ключевое слово
# dtype.

ex = np.ones(2, dtype=np.int64)
ex

np.ones((2, 3, 4), dtype=np.int16)

# 15.3.4. Вывод массивов
# Когда вы выводите массив на экран, NumPy отображает его аналогично вложенным
# спискам по таким правилам :
# 1. Последняя ось печатается слева направо;
# 2. Предпоследняя печатается сверху вниз;
# 3. Остальные оси печатаются сверху вниз, причем каждый фрагмент отделяется от
# следующего пустой строкой.
# Одномерные массивы выводятся как строки, двумерные - как матрицы, а трех
# мерные - как списки матриц.

alfa3 = np.arange(6)  # одномерный массив
print(alfa3)

beta3 = np.arange(12).reshape(4, 3)
print(beta3)

gamma = np.arange(24).reshape(2, 3, 4)
print(gamma)

# 15.4. Сортировка, добавление и удаление
# элементов массива
#
# 15.4.1 . Сортировка
# Сортировка элементов массива выполняется с помощью простой функции sort().
# При вызове функции вы можете указать ось, тип и порядок сортировки.
# Если мы возьмем этот массив:

arr1 = np.array([2, 1, 5, 3, 7, 4, 6, 8])
arr1

np.sort(arr1)

# В дополнение к функции sort(), которая возвращает отсортированную копию
# массива, вы можете использовать функции:
# ♦ argsort(), выполняющую непрямую сортировку по указанной оси;
# ♦ lexsort() для обратной устойчивой сортировки по нескольким ключам;
# ♦ searchsorted() , которая ищет элементы в отсортированном массиве;
# ♦ partition() для частичной сортировки

# 15.4.2. Сложение (конкатенация)
# Пусть у вас есть вот такие массивы:

alfa4 = np.array([1, 2, 3, 4])
beta4 = np.array([5, 6, 7, 8])

# Вы можете объединить их с помощью concatenate().

np.concatenate((alfa4, beta4))

# А вот такие массивы:

ex1 = np.array([(1, 2), (3, 4)])
why1 = np.array([(5, 6)])

np.concatenate((ex1, why1), axis=0)

# 15.4.3. Удаление
#
# Чтобы удалить элементы из массива, просто используйте индексирование и укажи-
# те элементы, которые вы хотите сохранить.
#
# 15.5. Форма и размер массива
# У массивов есть целый ряд важных атрибутов.
# ♦ ndarray.ndim - это количество осей или размерность массива.
# ♦ ndarray.size - это общее количество элементов массива. Это произведение раз
# меров массива.
# ♦ ndarray.shape - кортеж целых чисел, в котором хранятся размеры массива по
# каждому измерению. Если у вас есть двумерный массив с 2 строками и
# 3 столбцами, форма вашего массива будет(2, 3).
# Например, давайте создадим массив:

array_example = np.array(
    [
        [[0, 1, 2, 3], [4, 5, 6, 7]],
        [[0, 1, 2, 3], [4, 5, 6, 7]],
        [[0, 1, 2, 3], [4, 5, 6, 7]],
    ]
)

# Чтобы узнать размерность массива:

array_example.ndim

# Чтобы узнать общее количество элементов в массиве:

array_example.size

# Чтобы найти форму вашего массива:

array_example.shape

# 15.6. Изменение формы
# Метод ndarray.reshape() позволяет изменить форму массива без изменения данных.
# Просто помните, что, когда вы используете метод reshape(), массив, который вы
# хотите создать, должен содержать такое же количество элементов, что и исходный
# массив. Если вы меняете форму массива из 12 элементов, вам необходимо
# убедиться, что ваш новый массив тоже будет содержать 12 элементов.
# Пусть у нас есть такой массив:

alfa4 = np.arange(6)
print(alfa4)

# Вы можете использовать метод reshape ( ) для изменения формы вашего массива.
# Например, вы можете преобразовать его в массив из трех строк и двух столбцов:

beta4 = alfa4.reshape(3, 2)
print(beta4)

# Мы рассмотрели метод reshape() класса ndarray. А еще есть просто функция
# np.reshape() с необязательными параметрами.

np.reshape(alfa4, newshape=(2, 3))

np.reshape(alfa4, newshape=(2, 3), order="C")

np.reshape(alfa4, newshape=(2, 3), order="F")

np.reshape(alfa4, newshape=6, order="F")

# Здесь аlfa4 - это массив, который нужно изменить.
# Параметр newshape - это новая форма, которая вам нужна. Вы можете передать
# целое число или кортеж целых чисел. Если вы укажете целое число, получите
# одномерный массив такой длины.
# Для параметра order значение 'C' означает чтение/запись элементов с
# использованием порядка индекса в стиле языка С;
# 'F' означает чтение/запись элементов с использованием индекса в стиле языка Fortran. (Это необязательный параметр, его можно не указывать.)

# 15.7. Добавление оси
#
# Размерность массива можно увеличить с помощью newaxis() и expand_dims().
# Функция newaxis() позволяет увеличить размер вашего массива на одно измерение.
# Это означает, что одномерный массив станет двумерным, двумерный массив станет
# трехмерным и т. д.
# Пусть у нас есть такой массив:

alfa5 = np.array([1, 2, 3, 4, 5, 6])
alfa5

alfa5.shape

# Вы можете использовать newaxis() для добавления новой оси:

alfa6 = alfa5[np.newaxis, :]
alfa6

alfa6.shape

# Вы можете явно преобразовать одномерный массив в вектор-строку или в вектор
# столбец, используя newaxis(). Для преобразования одномерного массива в вектор
# строку добавьте ось в качестве первого измерения :

row_vector = alfa5[np.newaxis, :]
row_vector.shape

# В случае вектор-столбца, вы можете вставить ось во втором измерении:

col_vector = alfa5[:, np.newaxis]
col_vector.shape

col_vector

# Можно использовать функцию expand_dims ( ) , чтобы добавить ось в позицию с
# индексом 1:

beta5 = np.expand_dims(alfa5, axis=1)
beta5.shape

# А можно добавить ось в позицию с индексом О:

gamma2 = np.expand_dims(alfa5, axis=0)
gamma2.shape

# 15.8. Индексирование и срезы
# У массивов NumPy есть индексы и срезы, как и у списков Python.

data = np.array([1, 2, 3])

data[0]

data[1]

data[0:2]

data[1:]

data[-2:]

# Cхематично это выглядит так, как показано на рис. 15.6.
# ![image.png](attachment:image.png)

# Иногда нужно взять часть массива или его определенные элементы для дальнейше
# го анализа или дополнительной обработки. Для этого вам потребуется использовать
# подмножество, срез и/или индексы массива.
# Если требуется выбрать из массива значения, которые удовлетворяют определенным условиям, то с NumPy это сделать проще всего.
# Например, пусть у нас есть массив:

alfa7 = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
alfa7

# Все элементы массива меньше 5 :

print(alfa7[alfa7 < 5])

# Вы также можете выбрать числа, которые, например, больше или равны 5, и
# использовать это условие в индексе массива:

five_up = alfa7 >= 5
print(alfa7[five_up])

# Вы можете выбрать элементы, которые делятся на 2:

divisible_by_two = alfa7[alfa7 % 2 == 0]
print(divisible_by_two)

# Можно также выбрать элементы, которые удовлетворяют двум условиям,
# используя операторы & и |:

gamma3 = alfa7[(alfa7 > 2) & (alfa7 < 11)]
print(gamma3)

# Побитовые логические операторы & (И) и 1 (ИЛИ) можно использовать для
# получения логических значений, указывающих, соответствуют ли элементы
# массива определенному условию. Такой способ полезен для работы с массивами,
# в которых хранятся строки с именами или другими категориальными значениями.

five_up1 = (alfa7 > 5) | (alfa7 == 5)
print(five_up1)

# Вы также можете использовать функцию nonzero ( ) для выбора элементов или
# индексов из массива.
# Определим вот такой массив:

alfa8 = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]])
alfa8

# Вы можете использовать nonzero() для вывода индексов элементов, которые,
# например, меньше 5:

beta8 = np.nonzero(alfa8 < 5)
print(beta8)

# В этом примере возвращается кортеж массивов: по одному для каждого измерения.
# Первый массив содержит индексы строк всех значений, удовлетворяющих усло-
# вию, а второй массив - индексы столбцов этих значений.

print(alfa8[beta8])

# 15.9. Создание массива
# из существующих данных
# Вы можете легко создать новый массив из фрагмента уже существующего массива.
# Допустим, есть вот такой массив:

alfa9 = np.array((1, 2, 3, 4, 5, 6, 7, 8, 9, 10))

# Вы можете получить из него новый массив с помощью среза:

arr3 = alfa9[3:8]
arr3

# Соединить два существующих массива можно как по вертикали, так и по
# горизонтали.

alfa10 = np.array([(1, 1), (2, 2)])
beta10 = np.array([(3, 3), (4, 4)])

# Вы можете соединить их вертикально с помощью vstack():

np.vstack((alfa10, beta10))

# Или по горизонтали с помощью hstack():

np.hstack((alfa10, beta10))

# Вы можете разделить массив на несколько меньших массивов с помощью функции
# hsplit() . Вы можете указать либо количество возвращаемых массивов одинаковой
# формы, либо номера столбцов, после которых должно происходить деление.
# Допустим, есть массив:

ex3 = np.arange(1, 25).reshape(2, 12)
ex3

# Если вы хотите разделить этот массив на три массива одинаковой формы, поможет
# вот такой код:

np.hsplit(ex3, 3)

# Если вы хотите разделить массив после третьего и четвертого столбцов, выполните
# этот код:

np.hsplit(ex3, (3, 4))

# 15.1О. Копии и представления массивов
#
# При работе с массивами данные иногда копируются в новый массив, а иногда нет.
# Это часто сбивает с толку новичков. Есть три возможных варианта:
# 1 . Простое присваивание (без копии).
# 2. Представление или неглубокая копия.
# 3. Копирование или глубокая копия.

# 15.10.1. Присваивание без копии
# При простом присваивании объекты и их данные не копируются.

alfa11 = np.array([[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]])
beta11 = alfa11
beta11 is alfa11
# новый объект не создается
# а и Ь - два имени одного и того же объекта ndarray

# Python передает изменяемые объекты по ссылке, поэтому вызовы функций не
# копируются.

id(alfa11)


def print_id(ex4: object) -> None:
    """Функция выводит уникальный идентификатор объекта ex4.

    x: объект любого типа (object), для которого будет вычислен id.
    :return: None
    """
    print(id(ex4))


print_id(alfa11)

# 15.10.2. Представление или неглубокая копия
#
# В разных объектах массива могут использоваться одни и те же данные. Метод
# view() создает новый объект массива, который просматривает те же данные.

gamma11 = alfa11.view()
gamma11 is alfa11

gamma11.base is alfa11  # gamma11- это nредставление массива аlfa11

gamma11.flags.owndata

gamma11 = gamma11.reshape((2, 6))  # форма аlfa11 при этом не изменится
alfa11.shape

gamma11[0, 4] = 1234  # данные аlfa11 изменятся
alfa11

# Cрез массива возвращает его представление.

# +
ess = alfa11[:, 1:3]
ess[:] = 10  # ess[:] - т о же самое, что ess .

alfa11
# -

# 15.10.3. Глубокая копия
# Метод ndarray.сору() делает полную копию массива и его данных.

delta = alfa11.copy()
delta is alfa11

delta.base is alfa11

delta[0, 0] = 9999
alfa11

# Иногда метод сору() следует вызывать после получения среза, если исходный
# массив больше не нужен. Предположим, что а - это объемный промежуточный
# массив, а конечный результат ь содержит только небольшую часть а. Тогда при
# построении ь необходимо сделать глубокую копию:

alfa12 = np.arange(int(1e8))
beta12 = alfa12[:100].copy()
del alfa12  # и тогда nамять массива а может быть освобождена

# Если вместо этого использовать просто beta12 = alfa12[: 100], то beta будет ссылаться на аlfa, а массив аlfa останется в памяти, даже если выполнить инструкцию del а.

# 15.11. Массивы NumPy в реальной жизни
#
# 15.11.1. Электронные таблицы Excel
# Электронная таблица или таблица значений - это двумерная матрица. Каждый
# лист в Excel может быть отдельной переменной (рис. 15.7). Самая популярная
# абстракция в Python для этого случая - это объект Pandas DataFrame, работа которого
# основана на NumPy.
# ![image.png](attachment:image.png)

# 15.11.2. Аудиофайлы и временные ряды
#
# Аудиофайл - это одномерный массив семплов данных. Каждый семпл - это чис
# ло, представляющее собой крошечный фрагмент аудиосигнала. Звук в формате
# Audio CD записывается на скорости 44 1 00 семплов в секунду, и каждый семпл
# представляет собой целое число от -32 767 до 32 768. Это означает, что если
# у вас есть десятисекундный файл W А VE с качеством Audio CD, вы можете
# загрузить его в массив NumPy длиной 1 О * 44 1 00 = 44 1 ООО семплов.
# Если нужно получить первую секунду аудиофайла, просто загрузите файл в
# массив NumPy, который мы назовем, например, audio, и возьмите срез
# audio[:44100].
# ![image.png](attachment:image.png)

# 15.11.3 Изображения
# Изображение - это матрица пикселов размером «высота х ширина».
# Если изображение черно-белое (т. е. в оттенках серого), каждый пиксел может быть
# представлен одним числом (обычно от О (черный) до 255 (белый)). Если вам нужно
# получить верхнюю левую часть изображения размером 1 Ох 1 О пикселов, используя
# NumPy, достаточно взять срез [:10, :10].
# ![image.png](attachment:image.png)

# Если изображение цветное, то каждый пиксел представлен тремя числами, а
# именно значениями красного, зеленого и синего компонентов (RGB). В этом
# случае нам нужно 3-е измерение (потому что каждая ячейка может содержать
# только одно число). Итак, цветное изображение будет представлено трехмерным массивом размером «высота х ширина х 3» (рис.15.1О).
# ![image.png](attachment:image.png)

# 15.12. Резюме
# 1. Я изучила, как создать массив NumPy из случайных чисел, нулей или единиц;
# 2. Поняла, как создать последовательность с помощью функции arange();
# 3. Как добавлять, сортировать и удалять элементы из массива;
# 4. Узнала про методы shape() и size() для массива;
# 5. Как изменить форму массива, добавить ось в массив
# 6. Узнала про индексирование и срезы элементов массива;
# 7. Изучила создание массива из существующих данных;
# 8. Поняла, как создавать представления и глубокии копии
