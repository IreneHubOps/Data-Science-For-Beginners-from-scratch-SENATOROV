Список вопросов к видео https://t.me/c/1937296927/765/29780 (АЛГОРИТМ ПРИНЯТИЯ И ОТДАЧИ ДОМАШКИ):
    
(ОПЦИОНАЛЬНО)В ответе подробно всё опишите и обязательно нужно указывать тайм код из видео где я это сказал, по желанию, дополнительно прикладываем скриншот из видео.
Если вы знаете ответы на вопросы из Вашего опыта, то таймкоды из видео не надо указывать и т.д.

1) Как понять, что домашка пришла? 2) Как принять домашку?
В чате Home work свой ник с сообщение «Прими пул». 
Принимаем домашку:
Заходим в кошку. 
Нажимаем кнопку Fetch origin.
Смотрим History.
Видим коммиты. Самый верхний самый свежий коммит.
Заходим в коммит. Открываем файл в VScode.

3) Зачем нужна кнопка history и какие функции появляются при нажатии правой кнопки мыши на коммит?
Кнопка «History» в GitHub Desktop позволяет просматривать историю коммитов, включая детали о любых изменениях. С её помощью можно изучить, когда и кем были внесены правки в какие файлы и строки, как развивался проект в целом. 

При нажатии правой кнопкой мыши на коммит в GitHub Desktop появляется меню, в котором есть:

Amend commit
Это команда в Git, которая позволяет внести изменения в последний коммит в репозитории без создания дополнительных коммитов. 
Она позволяет объединить проиндексированные изменения с предыдущим коммитом без создания нового коммита. С её помощью можно отредактировать комментарий к предыдущему коммиту без изменения состояния кода в нём, а также добавить или удалить файлы из предыдущего коммита. 
Изменённый коммит не только редактирует последний коммит, но и полностью его заменяет, то есть изменённый коммит становится новой сущностью с отдельной ссылкой. 
Пример использования команды:  git commit --amend -m "Новое название коммита". Если запустить эту команду без указания нового сообщения (-m), откроется редактор, в котором можно изменить сообщение коммита.

Reset to commit
Команда git reset используется в Git для удаления коммитов.
Она позволяет удалять коммиты, отменять их без удаления, восстанавливать файлы из истории и так далее.
У команды git reset есть множество различных флагов и способов работы.
Примеры флагов:
— --hard означает полное удаление;
— HEAD~ означает «один коммит от последнего коммита»;
— если не указывать флаг --hard, то по умолчанию подразумевается флаг --mixed.
Изменение истории коммитов — опасная операция, которая чревата проблемами при синхронизации с удаленными репозиториями.

Checkout commit
Git checkout — это команда для переключения между ветками в системе контроля версий Git. С её помощью можно получать старые коммиты и прежние версии файлов, а также осуществлять навигацию по существующим веткам. 

Reorder commit
Reorder commits — это изменение порядка коммитов в истории ветки. Это позволяет сделать последовательность коммитов более осмысленной. 1
Например, в GitHub Desktop для переorder commits нужно перетащить коммит в истории ветки между двумя соседними коммитами.

Revert changes in commit
Функция отката изменений.

Create branch from commit
Функция создания ветки от коммита. Для этого нужно создать ветку, но не отправлять её на сервер, а по окончании работы удалить ветку.

Create tag …
Create tag — это команда для создания тега в Git. 24
Теги — это ссылки на конкретные версии кода в репозитории Git, которые используются для указания состояния кода в определённый момент времени.

Cherry-pick commit
Cherry-pick — это команда Git, которая переносит коммит(ы) из одной ветки в другую. Она берёт изменения, которые были сделаны в указанном коммите, и накладывает на текущую ветку. 
Например, если коммит попал в ветку по ошибке или нужно внести одинаковые изменения в другую ветку, с помощью cherry-pick можно перенести коммит в нужную ветку. 
Также эту команду можно использовать, чтобы применить определённые изменения перед созданием или слиянием запроса на слияние. 
Ещё один пример: если в ветке разработки зафиксирован баг, с помощью cherry-pick коммит с исправлением можно перенести в другие ветки проекта.
Таким образом, cherry-pick позволяет разработчикам передавать отдельные наборы изменений между ветками, что упрощает целевую интеграцию функций или исправлений ошибок без слияния целых веток.

Copy SHA
SHA — это идентификатор коммита, который можно найти в локальном репозитории или на платформах, таких как Github.
Он представляет собой адрес коммита, который направляет git к нужному месту назначения.
Чтобы получить SHA, можно выполнить следующие действия:
1.	Откройте терминал, перейдите в локальный репозиторий и введите команду git log. Это отобразит список коммитов с их соответствующими SHA.
2.	Если вы используете GitHub, можно найти идентификатор коммита, посетив веб-страницу репозитория и выбрав «commit» в меню репозитория. Это приведёт к истории коммитов. Каждый коммит отображает уникальную, усечённую версию SHA. Чтобы просмотреть всю SHA, нужно нажать на усечённую версию SHA. Полная SHA будет отображаться в адресной строке браузера.
В обоих случаях нужно скопировать и сохранить SHA интересующего коммита.

Copy tag
Копировать тег

View on GitHub
Просмотр на GitHub

3.1) Где брать ссылку на коммит? куда её отправлять? 
Через историю коммитов а кошке (или просто на гитхабе) открываем свой коммит и копируем ссылку из поисковой строки браузера. Отправляем в чат homework с текстом коммит отдала.

4) Что такое файл лога? 
Краткое содержание уроков.

4.1) Когда нужно его пушить?
Каждый раз после урока.

5) Что такое интерпритатор? 
Интерпретатор — это программа, которая выполняет код, написанный на языке программирования. Она не переводит его в машинные коды целиком, а построчно принимает команды и сразу выполняет их.
В отличие от компилятора, который преобразует исходный код в машинный код заранее, интерпретатор выполняет код построчно, читая и анализируя его непосредственно во время работы программы.

6) Где можно выбрать интерпритатор?
Чтобы выбрать интерпретатор Python в VS Code, нужно: 
1.	Открыть палитру команд (Ctrl + Shift + P в Windows и Linux). 
2.	Ввести python interpreter и нажать на «Python: Выберите интерпретатор». 
3.	В отобразившемся списке версий и интерпретаторов Python выбрать нужную версию и интерпретатор. 

Ещё один способ — использовать строку состояния: 
1.	Открыть файл Python. 
2.	Нажать на версию Python в строке состояния. 
3.	Выбрать правильный интерпретатор. 

Если не удаётся установить версию Python и интерпретатор через эти подходы, или предпочитаемый интерпретатор не отображается в меню, нужно указать полный путь к интерпретатору: 
1.	Открыть терминал и выполнить команду where python.
2.	Записать полный путь к интерпретатору. 
3.	Открыть палитру команд, ввести python interpreter и нажать на «Python: Выберите интерпретатор». 
4.	Нажать на кнопку «Ввести путь интерпретатора». 
5.	Выбрать «Найти». 
6.	Перейти к интерпретатору Python на компьютере и выбрать его. 

Также выбрать версию интерпретатора можно в панели активности в левом нижнем углу.

7) Что такое модуль? 
Это файл на языке Python, который содержит определенные функции, типы объектов и т.д. 
Это обычный файл .py или .ipynb.

8) Как создать и отправить коммит?
Заходим в Кошку. Даем название коммиту, описываем фактически выполненные действия. Commit to main. Push origin. History. Последний коммит view on GitHub. Забираем ссылку на коммит в браузере. Копируем ее в телеграмм, чат Home work с подписью коммит отдал.

9) Как посмотреть что коммит точно отправлен и находится в github?
Правой кнопкой мыши на коммит view on GitHub.

10) Какая команда показывает что код не прошёл проверки на ошибки? 
pre-commit run --all-files
Запускаем в терминале. Смотрим какие линтеры не прошли и почему (трассировка).

10.1) Напишите список линтеров которые используются для проверки кода и дайте их краткую характеристику.
1.	jupytext	Цель: Синхронизация между Jupyter Notebook и текстовыми форматами (например, .py, .md). 
 Не является линтером, а скорее инструментом для управления форматом ноутбука.

2.	docformatter	Цель: Форматирование документации (docstrings) в Python-коде.
 Особенность: Унифицирует стиль оформления документации, делая ее более читаемой.

3.	black	Цель: Форматирование Python-кода.
 Особенность: Строгое форматирование, не дает пользователю настройки стиля.
 Дополнительная информация: Используется как стандартный форматировщик в многих проектах.

4.	nbqa-black	Цель: Применение `black` к коду в Jupyter Notebook.
 Особенность: Удобный инструмент для форматирования кода в ноутбуках.

5.	pyupgrade	Цель: Обновление синтаксиса Python-кода.
 Особенность: Помогает обновить код к новым версиям Python.

6.	isort	Цель: Сортировка импортов в Python-коде.
 Особенность: Делает код более читаемым, унифицируя порядок импортов.

7.	nbqa-blacken-docs	 Цель: Применение `black` к строкам документации в Jupyter Notebook.
 Особенность: Удобный инструмент для форматирования документации в ноутбуках.

8.	nbqa-pyupgrade	Цель: Применение `pyupgrade` к коду в Jupyter Notebook.
 Особенность: Удобный инструмент для обновления синтаксиса кода в ноутбуках.

9.	nbqa-isort	Цель: Применение `isort` к коду в Jupyter Notebook.
 Особенность: Удобный инструмент для сортировки импортов в ноутбуках.

10.	codespell	Цель: Проверка на орфографические ошибки в коде и документации.
 Особенность: Обнаруживает ошибки в английских словах.

11.	nbqa-flake8	Цель: Применение `flake8` к коду в Jupyter Notebook.
 Особенность: Удобный инструмент для проверки стиля и качества кода в ноутбуках.

12.	flake8	Цель: Общая проверка стиля и качества Python-кода.
 Особенность: Выполняет проверку по правилам PEP 8, Pycodestyle, и т.д.

13.	nbqa-mypy	Цель: Применение `mypy` к коду в Jupyter Notebook.
 Особенность: Удобный инструмент для проверки типов в ноутбуках.

14.	mypy	Цель: Проверка типов в Python-коде.
 Особенность: Помогает обнаружить ошибки типов, связанные с использованием статической типизации.

15.	nbqa-pylint	Цель: Применение `pylint` к коду в Jupyter Notebook.
 Особенность: Удобный инструмент для проверки качества и стиля кода в ноутбуках.


16.	pylint	Цель: Глубокая проверка качества Python-кода.
 Особенность: Выполняет проверки на наличие ошибок, дублирования, неэффективного кода и др.

17.	nbqa-pydocstyle	Цель: Применение `pydocstyle` к коду в Jupyter Notebook.
 Особенность: Удобный инструмент для проверки документации в ноутбуках.

18.	pydocstyle	Цель: Проверка оформления документации (docstrings) в Python-коде.
 Особенность: Проверяет документацию на соответствие стандартам, таким как PEP 257.

11) Как узнать какой именно линтер не прошёл проверку?
В терминале VScode после выполнения pre-commit run --all-files появится отражение всего процесса прохождения линтеров. Перед текстом ошибки, помимо информации о местонахождении недочета, будет указано имя линтера, который эту ошибку обнаружил.
Также при запуске десктопного приложения GitHub кошка выдается перечень ошибок с указанием линтеров их выявивших. 

12) Линтер Pylint видит markdown?
Нет.

13) Номер ячейки в терминале и номер ячейки в vs code может отличаться? в каком случае?
Да. Номер ячейки в терминале и в VSCode отличается при наличии markdown ячеек.

14) Где посмотреть номер ячейки в vscode?
Нижний левый угол. Cell __ of ___.

15) В каком формате .ipynb отправляется в гитхаб? причём здесь JSON?

Файлы .ipynb отправляются в GitHub в формате JSON.
В основном они представляют собой текстовые файлы JSON, и Git обрабатывает их как любой другой текстовый файл. 
Формат .ipynb — это JSON-файл, который содержит полную запись сессий пользователя, включая код, описательный текст, уравнения и визуализации. 

16) Где посмотреть в какой ячейке ошибка?
В терминале после указания того какой линтер нашел ошибку, указывается код ошибки и место ее нахождения: файл/ячейка.

17) Как запустить терминал?
В верхнем меню VSCode во вкладке терминал.

18) Что такое линтер?
Линтер (от англ. слова lint) — это инструмент программирования, который используется для анализа исходного кода программного обеспечения с целью выявления потенциальных проблем, структурных ошибок, стилевых нарушений и других недочётов. 
Линтеры облегчают процесс разработки, помогая программистам улучшить качество своего кода, делая его более читаемым, поддерживаемым и безопасным. 
Основные задачи линтеров:
•	проверка соответствия кода стандартам оформления и соглашениям о наименовании переменных и функций; 
•	обнаружение потенциальных ошибок в коде, таких как неиспользуемые переменные, неправильное использование операторов и функций и другие логические ошибки; 
•	проверка на утечки памяти и другие проблемы, связанные с управлением ресурсами; 
•	анализ безопасности кода для выявления уязвимостей, таких как возможности SQL-инъекций, межсайтовых атак и других потенциальных угроз безопасности.  

19) В какой сайт нужно вставлять код ошибки если ошибка связана с pylint?
https://pylint.readthedocs.io/en/stable/index.html

20) Секция pydocstyle в большинстве случае автоматический закрывается после исправления ошибок в каком линтере?
Pylint.

21) Что такое описание модуля? Оно должно отражать информацию о том что находится в модуле?
Описание модуля - это ячейка (строка), которая должна описывать суть кода в написанного в модуле. Оно должно отражать информацию о том, что находится в модуле.

21) С какой  git команды начинается утро программиста?

Утро программиста, работающего с Git, может начинаться с команды git init — создания нового репозитория Git. 
Она создаёт первый коммит в репозитории, содержащий начальное состояние проекта, что позволяет отслеживать изменения в файлах и вернуться к предыдущим версиям проекта при необходимости.
Команда git init создает новый репозиторий Git. С ее помощью можно преобразовать существующий проект без управления версиями в репозиторий Git или инициализировать новый пустой репозиторий. Большинство остальных команд Git невозможно использовать без инициализации репозитория, поэтому данная команда обычно выполняется первой в рамках нового проекта.

22) После внесения изменений в файлах, кнопка open in vs code пропадает в кошке, как по другому открыть vs code из кошки?
Навести на нужный репозиторий. Нажать правой кнопкой мышки и нажать open in VScode.

23) Что такое stash?  
Stash — это временное хранилище для изменений в файлах, которые не готовы к коммиту.  
Он позволяет сохранять незавершенные изменения, не создавая новый коммит, что позволяет переключаться между задачами и возвращаться к незавершенным изменениям позже.
Stash changes - говорит нам о том, что в одном файле работает несколько человек и предлагает 
Git stash — это команда, которая позволяет на время «сдать в архив» (или отложить) изменения, сделанные в рабочей копии, чтобы применить их позже. 
Она перемещает текущие изменения в локальную директорию, которая выполняет роль специального хранилища, то есть скрывает эти изменения, сохраняя их отдельно. Таким образом, файлы рабочей копии возвращаются к своему исходному состоянию. 
Откладывание изменений полезно, если необходимо переключить контекст и пользователь пока не готов к созданию коммита. 
Процесс сохранения временных изменений состоит из двух этапов: 
1.	Stash (спрятать). На этом этапе все изменения сохраняются в специальном хранилище. Можно указать комментарий, с которым они будут сохранены. 
2.	Pop или apply (извлечь). После того как изменения скрыты, можно вернуть их обратно в рабочую директорию.

23.1) Как сохранить стэш?
  git командa(подсказка: https://t.me/c/1937296927/3602/19531): 
git stash save "NAME_STASH"
git stash apply "NUMBER_STASH"

  Кнопка в vs code:
1. Через панель Source Control (Ctrl+Shift+G):
   - Нажать на значок "Source Control" в левой панели
   - Нажать на кнопку с тремя точками (...)
   - Выбрать "Stash" -> "Stash Changes..."
   - Ввести описание для stash (опционально)

2. Через палитру команд (Ctrl+Shift+P):
   - Открыть палитру команд 
   - Ввести "Git: Stash"
   - Выбрать "Git: Stash" или "Git: Stash (Include Untracked)"
   - Ввести описание для stash (опционально)

3. Через контекстное меню в панели Source Control:
   - Правый клик на измененных файлах
   - Выбрать "Stash Changes..."
   - Ввести описание для stash (опционально)

23.2) Как восстановить стэш?

 Определение:
   - Это процесс возврата ранее сохраненных изменений из временного хранилища (stash) обратно в рабочую директорию
   - По сути, это извлечение отложенных изменений

Когда восстанавливать stash:
  - После переключения между ветками, когда нужно вернуть отложенные изменения
  - После получения и применения изменений от других разработчиков (pull)
  - После завершения срочной задачи, ради которой пришлось отложить текущие изменения
  - Когда нужно применить одни и те же изменения в разных ветках

Что происходит при восстановлении:
   - Изменения из stash применяются к текущей версии файлов
   - Код возвращается в состояние, в котором был до сохранения в stash
   - Если возникают конфликты с текущими изменениями, Git предложит их разрешить

Важные моменты:
   - Можно восстановить как последний сохраненный stash, так и любой из списка
   - При восстановлении нужно быть внимательным к текущим изменениям в файлах
   - Рекомендуется иметь чистую рабочую директорию перед восстановлением stash

Способы восстановления:

1. Через панель Source Control (Ctrl+Shift+G):
   - Нажать на значок "Source Control" в левой панели
   - Нажать на кнопку с тремя точками (...)
   - Выбрать "Stash" -> "Apply Stash..."
   - Выбрать нужный stash из списка

2. Через палитру команд (Ctrl+Shift+P):
   - Открыть палитру команд
   - Ввести "Git: Apply Stash"
   - Выбрать нужный stash из списка

3. Через Git команды в терминале:
   - git stash list (посмотреть список stash)
   - git stash apply stash@{n} (восстановить конкретный stash, где n - его номер)
   - git stash pop (восстановить последний stash и удалить его из списка)

Примечание: 
- Apply сохраняет stash в списке после восстановления
- Pop удаляет stash из списка после восстановления
- При конфликтах может потребоваться ручное разрешение
- Перед восстановлением убедитесь, что текущие изменения зафиксированы или также сохранены в stash

23.3) Различие между стэшем и коммитом.  
  Когда лучше сохранить изменения в стэше, а когда коммитить.
Различия между stash и commit:

1. Временность:
   - Stash: временное хранение изменений
   - Commit: постоянная фиксация изменений в истории проекта

2. Видимость:
   - Stash: локальный, не виден другим разработчикам
   - Commit: публичный, доступен всем после push

3. История:
   - Stash: не входит в историю проекта
   - Commit: является частью истории проекта

4. Структура:
   - Stash: простое сохранение текущих изменений
   - Commit: полноценная версия с сообщением, автором и датой

Когда использовать stash:
- При необходимости быстро переключиться на другую задачу
- Когда изменения не готовы для полноценного коммита
- При получении срочных обновлений от других разработчиков (pull)
- Для временного сохранения экспериментального кода

Когда использовать commit:
- После завершения логического блока работы
- Когда изменения протестированы и готовы к публикации
- При необходимости сохранить важную версию кода
- Когда нужно поделиться изменениями с командой


23.4) Как просмотреть список сохраненных стэшей?  
  git команда (подсказка: https://t.me/c/1937296927/3602/19531):

Просмотреть список сохраненных stash можно несколькими способами:

1. В терминале через Git команды:
   - git stash list               // показывает все сохраненные stash с их индексами
   - git stash show stash@{n}     // показывает детали конкретного stash, где n - его номер
   - git stash show -p stash@{n}  // показывает полные изменения в конкретном stash

2. В VS Code:
   - Открыть Source Control (Ctrl+Shift+G)
   - Нажать на три точки (...)
   - Выбрать "Stash" -> "View Stashed Changes"
   
Формат вывода git stash list:
stash@{0}: WIP on branch-name: commit-message    // самый последний stash
stash@{1}: On branch-name: stash-message         // предыдущий stash
stash@{2}: ...                                   // и так далее

Примечание:
- Индексация начинается с 0 (самый новый stash)
- WIP означает "Work In Progress" (работа в процессе)
- Каждая запись содержит ветку и сообщение коммита/stash

23.5) Как удалить стэш?  
  Команды для удаления отдельных стэшей или всех сразу.
  git команда (подсказка: https://t.me/c/1937296927/3602/19531):
Удалить stash можно следующими способами:

1. В терминале через Git команды:
   - git stash drop stash@{n}    // удалить конкретный stash, где n - его номер
   - git stash pop               // применить последний stash и удалить его
   - git stash clear            // удалить все stash-записи
   - git stash drop             // удалить последний stash

2. В VS Code:
   - Открыть Source Control (Ctrl+Shift+G)
   - Нажать на три точки (...)
   - Выбрать "Stash" -> "Clear Stashes" (удалить все)
   - Или выбрать конкретный stash и нажать на корзину рядом с ним

Важные примечания:
- Удаление stash необратимо
- Перед удалением убедитесь, что нужные изменения сохранены
- При использовании pop убедитесь, что изменения успешно применились
- Рекомендуется периодически очищать старые и неиспользуемые stash

Как проверить stash перед удалением:

1. Просмотр содержимого:
   - git stash list                  // посмотреть список всех stash
   - git stash show stash@{n} -p    // детально просмотреть изменения в конкретном stash
   - git stash show -p              // просмотреть последний stash

2. Безопасная проверка:
   - Создать временную ветку: git checkout -b temp_branch
   - Применить stash: git stash apply stash@{n}
   - Проверить изменения
   - Вернуться в исходную ветку: git checkout previous_branch
   - Удалить временную ветку: git branch -D temp_branch

3. Рекомендуемые шаги перед удалением:
   - Убедиться, что все важные изменения закоммичены
   - Проверить, нет ли важных экспериментальных изменений
   - Сделать скриншот списка stash для истории
   - При сомнениях - сохранить изменения в отдельную ветку

4. Признаки того, что stash можно удалить:
   - Изменения уже включены в коммиты
   - Stash устарел и больше не актуален
   - Эксперименты завершены или отменены
   - Временные изменения больше не нужны

23.6) Практические примеры использования стэша.  
  Краткие сценарии, где стэш помогает.

Практические примеры использования stash:

1. Срочное исправление бага:
   - Работаете над новой функцией
   - Поступает срочная задача исправить баг
   - git stash save "work on new feature"
   - Исправляете баг, коммитите
   - git stash pop // возвращаетесь к новой функции

2. Переключение между ветками:
   - Пишете код в feature-branch
   - Нужно срочно проверить что-то в main
   - git stash
   - git checkout main
   - После проверки возвращаетесь и git stash pop

3. Получение обновлений:
   - Работаете над задачей
   - Нужно получить свежие изменения (pull)
   - git stash
   - git pull
   - git stash pop

4. Экспериментальный код:
   - Пробуете новый подход
   - Не уверены в результате
   - git stash save "experimental approach"
   - Если эксперимент удачный - применяете stash
   - Если нет - удаляете stash

5. Код ревью:
   - Пишете новую функцию
   - Просят посмотреть чужой PR
   - git stash
   - Проверяете PR
   - git stash pop // возвращаетесь к своей работе

6. Временное переключение задач:
   - Работаете над долгосрочной задачей
   - Появляется быстрая задача
   - git stash save "long-term task"
   - Выполняете быструю задачу
   - Возвращаетесь к основной работе

24) Где посмотреть что есть конфликт в файлах? 

Обнаружить конфликты можно несколькими способами:

1. В VS Code:
   - Красные маркеры в Source Control панели (⚠️)
   - Цветовая подсветка в файлах:
     * Текущие изменения (зеленым)
     * Входящие изменения (синим)
     * Конфликтующие участки (красным)
   - Специальные маркеры в тексте:
     ```
     <<<<<<< HEAD
     ваш код
     =======
     другой код
     >>>>>>> branch-name
     ```

2. В терминале:
   - git status // покажет конфликтующие файлы красным
   - git diff // детальный просмотр различий
   - git merge --abort // отменить слияние при конфликтах

3. Инструменты разрешения в VS Code:
   - Кнопки "Accept Current Change"
   - "Accept Incoming Change"
   - "Accept Both Changes"
   - "Compare Changes"

4. Автоматические индикаторы:
   - VS Code показывает количество конфликтов
   - Подсвечивает проблемные места
   - Предлагает инструменты для разрешения

24.1) Когда он появляется?

Конфликты появляются в следующих ситуациях:

1. При слиянии веток (merge):
   - Одна и та же строка изменена в обеих ветках
   - Файл удален в одной ветке и изменен в другой
   - Файл изменен в обеих ветках по-разному

2. При восстановлении stash:
   - В рабочей директории есть несохраненные изменения
   - Изменения в stash затрагивают те же строки
   - Файлы были изменены после создания stash

3. При выполнении pull:
   - Локальные изменения конфликтуют с удаленными
   - Один и тот же файл изменен локально и удаленно
   - Структура проекта изменена обеими сторонами

4. При переключении веток (checkout):
   - Есть несохраненные изменения
   - Эти изменения конфликтуют с состоянием целевой ветки

5. При применении patch:
   - Изменения в patch конфликтуют с текущим состоянием
   - Файлы были изменены после создания patch

Как избежать:
- Чаще синхронизироваться с основной веткой
- Работать в разных файлах/областях кода
- Коммитить или стэшить изменения перед операциями
- Координировать работу с командой

25) Как решить конфликт в файлах?

Как решить конфликты в файлах:

1. В VS Code (рекомендуемый способ):
   - Открыть конфликтующий файл
   - Над конфликтом появятся кнопки:
     * Accept Current Changes (оставить ваши изменения)
     * Accept Incoming Changes (принять чужие изменения)
     * Accept Both Changes (оставить оба варианта)
     * Compare Changes (сравнить изменения)
   - Выбрать нужный вариант или отредактировать вручную
   - Сохранить файл
   - Добавить в git (git add)
   - Закоммитить решение конфликта

2. Ручное решение в редакторе:
   - Найти конфликтующие участки, помеченные:
     ```
     <<<<<<< HEAD
     ваш код
     =======
     чужой код
     >>>>>>> branch-name
     ```
   - Удалить маркеры конфликта
   - Оставить нужный код
   - Сохранить
   - Добавить в git

3. Важные шаги после решения:
   - Проверить работоспособность кода
   - Убедиться, что все конфликты решены
   - Закоммитить изменения
   - Протестировать функциональность

4. Если что-то пошло не так:
   - git merge --abort (отменить слияние)
   - git reset --hard (вернуться к последнему коммиту)
   - Начать заново с чистого состояния

26) Напишиие правильное утверждение
-Зелёное то что пришло с гитхаба и синее локальные изменения или синее то что пришло с гитхаба и зелёное это локальные изменения 

Правильное утверждение:

В VS Code при конфликтах:
- Зелёным цветом отмечаются локальные изменения (ваши текущие изменения)
- Синим цветом отмечаются входящие изменения (то, что пришло с GitHub)

Легко запомнить:
- Зелёный = "у меня" (локально)
- Синий = "из облака" (с GitHub)

27) Если мы работаем в одном файле, можно ли принять pull после того как вы спрячете в стэш свои изменения? 

Да, можно! Это стандартный и безопасный сценарий работы:

1. Правильная последовательность:
   - git stash save "мои изменения"    // прячем свои изменения
   - git pull                          // получаем изменения с GitHub
   - git stash pop                     // возвращаем свои изменения

2. Почему это работает:
   - Stash временно очищает рабочую директорию
   - Pull проходит без конфликтов с локальными изменениями
   - При возврате stash Git пытается объединить изменения

3. Возможные сценарии после git stash pop:
   - Изменения применяются без конфликтов (идеальный случай)
   - Возникают конфликты, которые нужно разрешить вручную
   - В любом случае, все изменения сохранены и ничего не потеряется

4. Преимущества такого подхода:
   - Безопасное получение обновлений
   - Сохранность ваших изменений
   - Контролируемое разрешение конфликтов

27.1) Что может произойти когда stash восстановите после принятия pull?

Возможные сценарии при восстановлении stash после pull:

1. Успешное восстановление:
   - Изменения не пересекаются
   - Stash применяется без конфликтов
   - Можно продолжать работу

2. Конфликты при восстановлении:
   - Если изменения в stash и pull затрагивают одни и те же строки
   - VS Code покажет конфликты:
     * Зеленым - ваши изменения из stash
     * Синим - изменения, полученные через pull
   - Потребуется ручное разрешение конфликтов

3. Возможные проблемы:
   - Структура файла сильно изменилась после pull
   - Логика кода изменилась и ваши правки уже неактуальны
   - Появились новые зависимости или требования

4. Как действовать:
   - Сначала проверить изменения после pull
   - Внимательно просмотреть конфликты
   - При сложных конфликтах можно:
     * Создать новую ветку для тестирования stash
     * Применить изменения частично
     * Обсудить изменения с командой

28) Сколько способов решения конфликтов было показано в видео? Напишите ЧИСЛО и укажите их способы.

3 способа. Принять изменения с гитхаба, принять локальные изменения, принять оба изменения.  

29) Что делает кнопка complete merge?

Кнопка "Complete merge" на GitHub:

1. Основное действие:
   - Объединяет изменения из Pull Request в целевую ветку
   - Создает merge commit
   - Закрывает Pull Request
   - Помечает PR как "merged" (объединённый)

2. Что происходит при нажатии:
   - Проверяются все автоматические тесты
   - Проверяются конфликты
   - Создается коммит слияния
   - Обновляется целевая ветка
   - Обновляется история проекта

3. Когда использовать:
   - После одобрения код-ревью
   - Когда все тесты пройдены
   - При отсутствии конфликтов
   - Когда изменения готовы к внедрению

4. Важные моменты:
   - Действие необратимо
   - Требует соответствующих прав доступа
   - Лучше использовать после проверки кода
   - Можно настроить автоматическое удаление ветки после merge

30) В какой чат нужно писать если остались вопросы?

https://t.me/c/1937296927/2415

31) Что такое FORK? Зачем его делают? 

FORK (форк) - это копия репозитория на GitHub:

1. Что такое форк:
   - Полная копия чужого репозитория в ваш аккаунт GitHub
   - Независимая версия проекта
   - Имеет связь с оригинальным репозиторием
   - Сохраняет всю историю коммитов

2. Зачем делают форк:
   - Для внесения изменений в чужой проект
   - Для создания Pull Request (запрос на внесение изменений)
   - Для использования чужого кода как основы своего проекта
   - Для экспериментов без влияния на оригинальный код
   - Для обучения и практики

3. Типичные сценарии использования:
   - Исправление багов в open-source проектах
   - Добавление новых функций
   - Создание своей версии проекта
   - Работа над учебными заданиями
   - Совместная разработка

4. Преимущества форка:
   - Безопасная работа с кодом
   - Возможность синхронизации с оригиналом
   - Полный контроль над своей копией
   - Возможность вернуть изменения в основной проект

32) Как скачать форкнутый репозиторий на локальный компьютер?

Как скачать форкнутый репозиторий:

1. Через HTTPS (рекомендуемый способ):
   - Перейти в свой форк на GitHub
   - Нажать зеленую кнопку "Code"
   - Скопировать HTTPS ссылку
   - В терминале выполнить:
     git clone https://github.com/ваш-логин/название-репозитория.git

2. Через VS Code:
   - Ctrl + Shift + P
   - Ввести "Git: Clone"
   - Вставить URL вашего форка
   - Выбрать папку для клонирования

3. Настройка связи с оригинальным репозиторием:
   - git remote add upstream https://github.com/оригинальный-автор/название-репозитория.git
   - git remote -v (проверить список удаленных репозиториев)

4. Важные моменты:
   - Клонировать нужно именно ваш форк, а не оригинальный репозиторий
   - После клонирования автоматически добавляется remote origin
   - Рекомендуется сразу настроить upstream для синхронизации с оригиналом

33) С какой вероятностью ваши ошибки были уже решены? и кто их решил?

90 %
Большая часть ошибок уже решена членами сообщества/Русланом))

34) Как создать файл в vs code?
Чтобы создать файл в Visual Studio Code, можно воспользоваться следующими способами:
1.	Через меню «Файл». Нужно зайти в меню «Файл» и выбрать пункт «Создать».  
2.	С помощью горячих клавиш.  Для создания нового файла следует нажать комбинацию клавиш Ctrl+N.  
3.	Через палитру команд. 3 Её можно вызвать сочетанием Ctrl+Shift+P. Для создания нового файла нужно ввести в появившемся поле File: New File и нажать Enter.  
Также для создания файлов и папок можно воспользоваться контекстным меню.  

35) Файл лога нужно заполнять в конце каждого урока?
Да!
==================

Дополнительные вопросы:

1)Какая команда конвертирует файл в py из ipynb? 
Для конвертации файла Jupyter Notebook с расширением .ipynb в Python файл с расширением .py вы можете использовать команду jupyter nbconvert.
В нашем  .pre-commit-config.yaml это делается автоматически.

    hooks:
     - id: jupytext
       entry: jupytext
       language: python
       types: [jupyter]
       args:
         - --from=ipynb
         - --to=py:light
         - --set-formats=ipynb,py:light
         - --quiet
         - --sync
         - --warn-only
       exclude: '.*\.md$'

Этот код — это настройка для инструмента pre-commit, который автоматически выполняет определенные действия перед тем, как вы сделаете коммит в Git. В данном случае, он будет конвертировать файлы Jupyter Notebook (.ipynb) в Python файлы (.py) и наоборот.



подсказка https://t.me/c/1937296927/1/26527 

2) Что такое пакетный менеджер? Вы пользуетесь пакетным менеджером conda или pip? Какой лучше использовать для дата сайнс?

Пакетный менеджер - это инструмент для установки, обновления, настройки и удаления программных пакетов в операционной системе.

Сравнение pip и conda:

pip:
Менеджер пакетов Python по умолчанию
Устанавливает только Python-пакеты
Легче и быстрее
Использует PyPI (Python Package Index)

conda:
Менеджер пакетов и окружений
Устанавливает пакеты для разных языков (не только Python)
Лучше управляет зависимостями
Включает предкомпилированные бинарные файлы

Для Data Science лучше использовать conda потому что:
Лучше работает с научными библиотеками (numpy, pandas, scipy)
Решает конфликты зависимостей эффективнее
Устанавливает не только Python-пакеты, но и внешние зависимости
Предоставляет предкомпилированные пакеты (быстрее установка)
Хорошо работает с GPU (для deep learning)
Проще создавать изолированные окружения

3) Почему расширение py лучше чем ipynb?

Преимущества .py файлов перед .ipynb:

1. Контроль версий (Git):
   - Лучшее отслеживание изменений
   - Простое разрешение конфликтов
   - Чистая история изменений без метаданных
   - Эффективная командная работа

2. Производительность:
   - Быстрая загрузка
   - Меньше потребление памяти
   - Нет хранения результатов выполнения
   - Эффективность при больших проектах

3. Модульность и импорт:
   - Простой импорт функций между файлами
   - Лучшая организация кода
   - Возможность создания пакетов

4. Профессиональная разработка:
   - Полная поддержка всех IDE
   - Продвинутые инструменты отладки
   - Качественное автодополнение
   - Удобное написание тестов

5. Чистота кода:
   - Гарантированный порядок выполнения
   - Нет проблем с состоянием ячеек
   - Лучшая структура кода
   - Следование стандартам PEP 8

6. Командная работа:
   - Эффективное код ревью
   - Легкое масштабирование
   - Лучшая совместимость с CI/CD
   - Простое развертывание

Рекомендация: использовать .ipynb для исследований и прототипирования, 
а .py для финального продакшен-кода.

4) Что такое pep8? 

PEP 8 - руководство по стилю кода Python (Python Enhancement Proposal 8)

1. Отступы:
   - 4 пробела для отступа
   - Не использовать табуляцию
   - Максимальная длина строки: 79 символов

2. Импорты:
   - Каждый импорт на новой строке
   - Группировка импортов: стандартная библиотека, сторонние пакеты, локальные модули
   - Порядок: import sys; from os import path

3. Пробелы:
   - После запятой: yes, no
   - Вокруг операторов: x = 1 + 2
   - Не использовать в скобках: func(arg1, arg2)

4. Именование:
   - Классы: CamelCase
   - Функции и переменные: snake_case
   - Константы: UPPER_CASE
   - Защищённые атрибуты: _protected
   - Приватные атрибуты: __private

5. Комментарии:
   - # После решётки пробел
   - Комментарии на уровне строки
   - Docstrings для модулей/классов/функций

6. Структура кода:
   - Две пустые строки между классами
   - Одна пустая строка между методами
   - Избегать лишних пробелов

подсказка:https://peps.python.org/pep-0008/

4.1) линтеры проверяют на соблюдение pep8?

Да, линтеры проверяют на соблюдение PEP 8.

4.2) Какая нотация используется для создания переменных? 

"""
В Python используются следующие нотации для именования переменных:

1. snake_case (рекомендуется PEP 8 для переменных и функций):
"""
first_name = "John"
user_age = 25
calculate_total = lambda x, y: x + y

"""
2. camelCase (обычно не рекомендуется в Python):
"""
firstName = "John"  # не рекомендуется
userAge = 25       # не рекомендуется

"""
3. PascalCase (для классов):
"""
class UserAccount:
    pass

class DataProcessor:
    pass

"""
4. UPPER_CASE (для констант):
"""
MAX_VALUE = 100
PI = 3.14159
BASE_URL = "https://api.example.com"

"""
5. Защищённые и приватные переменные:
"""
_protected_var = "protected"     # одно подчеркивание
__private_var = "private"       # два подчеркивания

"""
Правила именования переменных:
1. Начинаются с буквы или подчеркивания
2. Могут содержать буквы, цифры и подчеркивания
3. Регистрозависимые
4. Не могут быть ключевыми словами Python

Запрещено:
"""
# 1name = "John"     # нельзя начинать с цифры
# my-name = "John"   # нельзя использовать дефис
# class = "Python"   # нельзя использовать ключевые слова

"""
Специальные имена (dunder методы):
"""
__init__ = "constructor"
__str__ = "string representation"
__len__ = "length method"

"""
Рекомендации:
1. Использовать описательные имена
2. Избегать однобуквенных имен (кроме счетчиков)
3. Соблюдать соглашения PEP 8
4. Быть последовательным в выбранном стиле
"""

ответ на 85-95 страницы https://t.me/c/1937296927/1/16676

4.3) Может ли переменная состоять из одной буквы например андерскор  "_" 

Да, может.

4.4) Зачем и где мы используем андерскор _ 

Идентификаторы: В языках программирования, таких как Python, андерскоры часто используются в именах переменных и функций для улучшения читаемости. Например, my_variable вместо myvariable.

Скрытые атрибуты: В Python один или два андерскора перед именем атрибута класса указывают на то, что этот атрибут является "приватным" или "защищенным". Например, _private_variable или __private_variable.

Форматирование: В некоторых языках разметки, таких как Markdown, андерскоры используются для выделения текста курсивом или жирным шрифтом. Например, _курсив_ или __жирный__.

Разделение слов: Андерскоры могут использоваться для разделения слов в именах файлов или переменных, особенно когда пробелы недопустимы.

4.5) По PEP8 допустима переменная в одну букву?

Да, допустима, но в строго определенных случаях.

ответ на 85-95 страницы https://t.me/c/1937296927/1/16676


